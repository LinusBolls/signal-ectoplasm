/**
 * SignalHistoryClient interacts with db.sqlite, the file where Signal Desktop stores
 * information about conversations.
 * 
 * the file is encrypted using a key stored in a config.json, generated by Signal Desktop.
 * 
 * the class handles reading the key, decrypting the database, creating a connection to the database, and destroying the connection.
 * 
 * if you're feeling risky, you can call _dbAll or _executeRawQuery, but in most cases the non-prefixed methods
 * should be preferred for their typesafety.
 * 
 * the class also handles retrying failed queries if they are caused by SQLITE_NOTADB.
 * this error is often caused by the signal app interacting with dq.sqlite, temporarily blocking the file for a few milliseconds.
 * 
 * TODO: some more type safety, especially for messages and Message.json
 * TODO: rethink how to return information about contacts other than the Message.sender field.
 * TODO: better documentation and custom Errors
 * TODO: logging options `logExecutionTimes` and `logVerbose` (read into how log levels work)
 * 
 */
import fs from "fs"
import os from "os"
import { performance } from "perf_hooks"

import sqlcipher from "@journeyapps/sqlcipher"
import { identifySqliteError } from "./SqliteError"
import { FaultyManualConnectionManagementError, UnauthorizedConnectionManagementError } from "./SignalHistoryClientError"
import { Conversation, GroupMessageJson, Message } from "./signal.types"

export interface SignalConfigJsonContents {
  key: string
  mediaPermissions: boolean
}

async function readJsonFile<T extends unknown>(path: string) {
  try {
    const file = await fs.promises.readFile(path, "utf8");

    const data: T = JSON.parse(file);

    return [null, data] as const;
  } catch (err) {
    return [err, null] as const
  }
}

/** util types for SignalHistoryClient.getAllMessages */
interface MessageOptionFields {
  parseJson: { jsonData: GroupMessageJson };
  includeMemberInfo: { sender: { id: string; name: string } };
}
type GetAllMessagesOptions = Partial<Record<keyof MessageOptionFields, boolean>>;

type ApplyOptions<T, U> = T extends true ? U : {};

export type MessageWithOptions<
  T extends GetAllMessagesOptions = GetAllMessagesOptions
> = Message &
  ApplyOptions<T['parseJson'], { jsonData: GroupMessageJson }> &
  ApplyOptions<T['includeMemberInfo'], { sender: { id: string; name: string } }>;

export const getPossibleSignalAppDataDirectory = (): string => {
  const platform = os.platform();
  const homeDir = os.homedir();

  if (platform === "darwin") {
    // macOS
    return `${homeDir}/Library/Application Support/Signal`;
  } else if (platform === "win32") {
    // Windows
    const appData = process.env.APPDATA || `${homeDir}/AppData/Roaming`;

    return `${appData}/Signal`;
  } else {
    // Linux and other Unix-like systems
    return `${homeDir}/.config/Signal`;
  }
}
const DEFAULT_DB_SQLITE_PATH = getPossibleSignalAppDataDirectory() + "/sql/db.sqlite"
const DEFAULT_CONFIG_JSON_PATH = getPossibleSignalAppDataDirectory() + "/config.json"

export default class SignalHistoryClient {

  dbSqlitePath = ""
  configJsonPath = ""
  private db: sqlcipher.Database | null = null
  manuallyManageConnectionPleaseReadTheDocsOnThis = false
  numberOfPastConnections = 0
  private connectedUnixTime = 0

  isConnected = false

  /**
   * finds, decrypts, and creates a connection to Signal's Sqlite database.
   * 
   * @param {string} [options.dbSqlitePath=DEFAULT_DB_SQLITE_PATH] - path to Signal's `db.sqlite` file. defaults based on your operating system, so you probably don't have to pass this manually.
   * @param {string} [options.configJsonPath=DEFAULT_CONFIG_JSON_PATH] - path to Signal's `config.json` file. defaults based on your operating system, so you probably don't have to pass this manually.
   * @param {boolean} [options.manuallyManageConnectionPleaseReadTheDocsOnThis=false] - by default, SignalHistoryClient creates a new a database connection for every query in order to not block Signal Desktop from accessing the file, but you can handle this yourself (no performance gain). i have personally not found a good reason to do this.
   * ```js
   * 
   * // basic usage:
   * async function main() {
   * 
   *   const client = new SignalHistoryClient();
   * 
   *   await client.getAllConversations();
   * }
   * 
   * // loading from alternative paths:
   * async function main() {
   * 
   *   const client = new SignalHistoryClient({ 
   *     dbSqlitePath: "/Users/foo/downloads/db.sqlite",
   *     configJsonPath: "/Users/foo/downloads/config.json",
   *   });
   * 
   *   await client.getAllConversations();
   * }
   * 
   * // manually managing the connection (THIS MERELY INCREASES PERFORMANCE BY A FEW MILLISECONDS PER QUERY AND IS NOT WORTH IT):
   * async function main() {
   * 
   *   const client = new SignalHistoryClient({ manuallyManageConnectionPleaseReadTheDocsOnThis: true });
   * 
   *   await client.connect();
   * 
   *   // a lot of queries
   * 
   *   await client.disconnect();
   * }
   * ```
   */
  constructor({
    dbSqlitePath = DEFAULT_DB_SQLITE_PATH,
    configJsonPath = DEFAULT_CONFIG_JSON_PATH,
    manuallyManageConnectionPleaseReadTheDocsOnThis = false
  } = {}) {

    this.dbSqlitePath = dbSqlitePath
    this.configJsonPath = configJsonPath
    this.manuallyManageConnectionPleaseReadTheDocsOnThis = manuallyManageConnectionPleaseReadTheDocsOnThis
  }
  async connect() {

    if (!this.manuallyManageConnectionPleaseReadTheDocsOnThis) throw new UnauthorizedConnectionManagementError()

    return await this._connect()
  }
  async disconnect() {

    if (!this.manuallyManageConnectionPleaseReadTheDocsOnThis) throw new UnauthorizedConnectionManagementError()

    return await this._disconnect()
  }
  private async _connect() {
  
    const startTime = performance.now()

    this.connectedUnixTime = startTime

    const sqlite3 = sqlcipher.verbose()

    /**
     * even though this is synchronous we can't do it in the constructor
     * because connecting, disconnecting, and connecting again to the same 
     * sqlite3.Database instance throws "SQLITE_MISUSE: Database is closed".
     */
    this.db = new sqlite3.Database(this.dbSqlitePath);

    const [configErr, configData] = await readJsonFile<SignalConfigJsonContents>(this.configJsonPath)

    if (configErr != null) throw new Error(`[signal-history-client] FATAL error trying to read signal config.json at "${this.configJsonPath}": ${configErr}`)

    const { key } = configData!

    // use SQLCipher v4, the protocoll Signal uses to encrypt db.sqlite
    this.db!.run("PRAGMA cipher_compatibility = 4");

    // decrypt database using the key we got from the config.json
    // see: https://www.zetetic.net/sqlcipher/sqlcipher-api/
    this.db!.run(`PRAGMA key = "x'${key}'"`);

    // we want to be able to await ._connect(), so we wrap the callback in a promise
    return await new Promise<void>(resolve => this.db!.serialize(() => {

      const endTime = performance.now();
  
      const elapsedTime = Math.round(endTime - startTime);
  
      console.info(`[signal-history-client] connected in ${elapsedTime}ms`)

      this.isConnected = true

      this.numberOfPastConnections += 1
      
      resolve()
    }));
  }
  private async _disconnect() {

    const startTime = performance.now()

    // we want to be able to await ._disconnect(), so we wrap the callback in a promise
    return await new Promise<void>(resolve => this.db!.close(() => {

      const endTime = performance.now();
  
      const elapsedTime = Math.round(endTime - startTime);

      const elapsedTimeSinceConnectionOpened = Math.round(endTime - this.connectedUnixTime)
  
      console.info(`[signal-history-client] disconnected in ${elapsedTime}ms after being open for ${elapsedTimeSinceConnectionOpened}ms`)
  
      this.isConnected = false
    
      resolve()
    }));
  }
  async _dbAll<T extends unknown>(query: string): Promise<[null, T[]] | [unknown, []]> {

    if (!this.isConnected) {

      if (this.manuallyManageConnectionPleaseReadTheDocsOnThis) throw new FaultyManualConnectionManagementError("")
      
      await this._connect()
    }

    const WAIT_TIME_UNTIL_CONNECTION_RETRY_MS = 10
    const MAX_CONNECTION_RETRIES = 10

    const res = await new Promise<[null, T[]] | [unknown, []]>((resolve, reject) => {

      let currentConnectionRetries = 0

      const tryToExecuteQuery = async () => {

          if (!this.isConnected) {

            if (this.manuallyManageConnectionPleaseReadTheDocsOnThis) throw new FaultyManualConnectionManagementError("")

            throw new Error("if you see this error, i'm afraid SignalHistoryClient is fatally broken")
          }

          this.db!.all(query, (err: unknown, rows: T[]) => {
            if (err) {

              const sqliteErr = identifySqliteError(err)

              if (!sqliteErr.mightBeSolvedByRetry) {

                console.error("[signal-history-client] FATAL query failed:", sqliteErr.id)

                resolve([err, []])

                return
              }
              currentConnectionRetries += 1;

              if (currentConnectionRetries > MAX_CONNECTION_RETRIES) {

                console.error("[signal-history-client] FATAL query failed after exceeding maximum amount of retries")
                
                resolve(["Exceeded maximum amount of retry attempts trying to connect to database", []])

                return
              }
              // retry because connection might only be temporarily blocked
              setTimeout(tryToExecuteQuery, WAIT_TIME_UNTIL_CONNECTION_RETRY_MS)

              return
            }
            if (currentConnectionRetries > 0) console.info(`[signal-history-client] query succeeded after ${currentConnectionRetries} retries`)
      
            resolve([null, rows]);
          });
      }
      tryToExecuteQuery()
  });
  if (!this.manuallyManageConnectionPleaseReadTheDocsOnThis) {
    await this._disconnect()
  }
  return res
  }
  async getDatabaseInfo() {

    const tables = await this._dbAll(
      "SELECT name FROM sqlite_schema WHERE type ='table' AND name NOT LIKE 'sqlite_%'"
    );
    // const jobs = await this._dbAll("SELECT * FROM jobs"); // empty
    const items = await this._dbAll("SELECT * from items") // random settings and stuff
    // const reactions = await this._dbAll("SELECT * from reactions") // not interesting rn, we already get this in the Message.json
    const identityKeys = await this._dbAll("SELECT * from identityKeys") // uninteresting
    const senderKeys = await this._dbAll("SELECT * from senderKeys") // uninteresting
    // const badges = await this._dbAll("SELECT * from badges") // empty

    return { tables, identityKeys, senderKeys, items }
  }
  async getAllConversationsWithMessages() {

    const startTime = performance.now()

    const query = `
      SELECT conversations.*, (
        SELECT COUNT(*) FROM messages WHERE messages.conversationId = conversations.id
      ) AS numMessages
      FROM conversations;
    `

    const queryRes = await this._dbAll<Conversation>(query);

    const endTime = performance.now();
  
    const elapsedTime = Math.round(endTime - startTime);

    console.info(`[signal-history-client] getAllConversationsWithMessages in ${elapsedTime}ms`)

    return queryRes
  }
  async getAllConversations() {

    const startTime = performance.now()

    const queryRes = await this._dbAll<Conversation>("SELECT * FROM conversations");

    const endTime = performance.now();
  
    const elapsedTime = Math.round(endTime - startTime);

    console.info(`[signal-history-client] getAllConversations in ${elapsedTime}ms`)

    return queryRes
  }
  /**
   * @param {string} [options.parseJson=false] - whether to include the `jsonData` field in each message (no performance loss)
   * @param {string} [options.includeMemberInfo=false] - whether to include the `sender` field in each message (high performance loss)
   *
   */
  async getAllMessages<T extends GetAllMessagesOptions = GetAllMessagesOptions>(
    conversationId: string,
    options: T = {} as T
  ): Promise<[null, Array<MessageWithOptions<T>>] | [unknown, []]> {

    const startTime = performance.now();

    const {
      parseJson = false,
      includeMemberInfo = false,
    } = options;

    const [messagesErr, messages] = await this._dbAll<Message>(
      `SELECT * from messages WHERE conversationId = '${conversationId}'`
    );
    if (messagesErr || !messages) {

      return [messagesErr, []]
    }

    if (includeMemberInfo) {
      const [conversationsErr, conversations] = await this.getAllConversations()

      if (conversationsErr != null) {
        return [conversationsErr, []]
      }

      // @ts-ignore
      const convoInfo = conversations!.reduce<Record<string, { id: string, name: string }>>((obj, convo) => ({ ...obj, [convo.uuid ?? convo.groupId]: { id: convo.uuid ?? convo.groupId, name: convo.name! } }), {})

      // const thisConvo = conversations.filter(i => i.id === conversationId)[0]

      // const members = (thisConvo.members ?? "").split(" ").map(id => convoInfo[id])

      for (const message of messages) {

        (message as Message & MessageOptionFields['includeMemberInfo']).sender = convoInfo[message.sourceUuid];
      }
    }
    if (parseJson) {
      for (const message of messages) {

        const jsonData = JSON.parse(message.json) as GroupMessageJson

        (message as Message & MessageOptionFields['parseJson']).jsonData = jsonData;
      }
    }
    const endTime = performance.now();
  
    const elapsedTime = Math.round(endTime - startTime);

    console.info(`[signal-history-client] getAllMessages in ${elapsedTime}ms`)

    return [null, messages as Array<MessageWithOptions<T>>]
  }
}

